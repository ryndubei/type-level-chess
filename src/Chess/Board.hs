{-# LANGUAGE RoleAnnotations #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GADTs #-}
module Chess.Board
  ( Board
  , makeMove
  , makeMoveInvariant
  , initialBoard
  , initialBoardInvariant
  , BoardInvariant(pieceAtUnique, kingUnique, kingExists, ifEmptyNotPiece, ifPieceNotEmpty)
  ) where

import Chess.Types
import Chess.Moves
import qualified Fcf as F
import Data.Singletons.Base.Enum
import qualified Fcf.Data.List as F
import Prelude.Singletons
import Data.Type.Equality
import Unsafe.Coerce
import Data.Singletons.Decide

data Board (facts :: FactSet) = Board

type role Board nominal

-- Helpers for initialBoard
type CellsOfVertical = ((F.Flip F.Map) (EnumFromTo MinBound MaxBound) F.<=< F.Pure1 (F.Flip (F.Pure2 'Cell)))
type PawnRankCells (c :: Colour) = F.Eval (CellsOfVertical (PawnRank c))
type CellsToFacts (f :: Cell -> F.Exp Fact) (cs :: [Cell]) = F.Eval (F.Map f cs)
type Pawns (c :: Colour) = CellsToFacts (F.Pure1 (HasPiece Pawn c)) (PawnRankCells c)

type InitialFacts boardConstructor
  = forall whitePawns blackPawns blackKing whiteKing emptyCells emptyFacts facts.
    ( whitePawns ~ Pawns 'White
    , blackPawns ~ Pawns 'Black
    , blackKing ~ HasKing 'Black ('Cell 'E 'Eight)
    , whiteKing ~ HasKing 'White ('Cell 'E 'One)
    , emptyCells ~ F.Eval (F.ConcatMap CellsOfVertical (EnumFromTo Three Six))
    , facts ~ FactSetFromList
        ( whitePawns
       ++ blackPawns
       ++ '[ blackKing, whiteKing ]
       ++ emptyFacts
        )
    ) => boardConstructor facts

-- | Properties the board can be expected to always follow, if it represents a
-- game starting from 'initialBoard'.
data BoardInvariant facts = BoardInvariant
  { pieceAtUnique
      :: forall piece1 piece2 colour1 colour2 cell.
         SPiece piece1
      -> SPiece piece2
      -> SColour colour1
      -> SColour colour2
      -> SCell cell
      -> (FactHolds (HasPiece piece1 colour1 cell) facts :~: 'True)
      -> (FactHolds (HasPiece piece2 colour2 cell) facts :~: 'True)
      -> (piece1 :~: piece2, colour1 :~: colour2)
  , kingUnique
      :: forall colour cell1 cell2.
         SColour colour
      -> SCell cell1
      -> SCell cell2
      -> (FactHolds (HasKing colour cell1) facts :~: 'True)
      -> (FactHolds (HasKing colour cell2) facts :~: 'True)
      -> cell1 :~: cell2
  , kingExists
      :: forall colour.
         SColour colour
      -> SomeKing colour facts
  , ifEmptyNotPiece
      :: forall colour cell piece.
         SColour colour
      -> SCell cell
      -> SPiece piece
      -> (FactHolds (IsEmpty cell) facts :~: 'True)
      -> (FactHolds (HasPiece piece colour cell) facts :~: 'False)
  , ifPieceNotEmpty
      :: forall colour cell piece.
         SColour colour
      -> SCell cell
      -> SPiece piece
      -> (FactHolds (HasPiece piece colour cell) facts :~: 'True)
      -> (FactHolds (IsEmpty cell) facts :~: 'False)
  }

initialBoard :: InitialFacts Board
initialBoard = Board

-- TODO: get rid of unsafeCoerce:
-- I'm fairly sure BoardInvariant can be directly proven
-- on the type level: if not with the current fact set representation, then with something
-- else (could e.g. store proofs of all the facts we could request in the Board type)
-- But this is not an urgent problem: as long as we verify that the use of unsafeCoerces here
-- is sound, no invalid game will be generated by any other module importing this.
unsafeRefl :: a :~: b
unsafeRefl = unsafeCoerce Refl

initialBoardInvariant :: InitialFacts BoardInvariant
initialBoardInvariant = BoardInvariant
  { pieceAtUnique = \piece1 piece2 colour1 colour2 cell Refl Refl -> (unsafeRefl, unsafeRefl)
  , kingUnique = \colour cell1 cell2 Refl Refl -> unsafeRefl
  , ifEmptyNotPiece = \colour cell piece Refl -> unsafeRefl
  , ifPieceNotEmpty = \colour cell piece Refl -> unsafeRefl
  , kingExists = \case
      SWhite -> SomeKing Refl (SCell SE SOne)
      SBlack -> SomeKing Refl (SCell SE SEight)
  }

makeMoveInvariant :: SColour colour -> SCell moveTo -> Move colour moveFrom moveTo facts facts' -> BoardInvariant facts -> BoardInvariant facts'
makeMoveInvariant sColour sMoveTo !m bi@BoardInvariant{} = BoardInvariant
  { pieceAtUnique = \piece1 piece2 colour1 colour2 cell Refl Refl -> (unsafeRefl, unsafeRefl)
  , kingUnique = \colour cell1 cell2 Refl Refl -> unsafeRefl
  , ifEmptyNotPiece = \colour cell piece Refl -> unsafeRefl
  , ifPieceNotEmpty = \colour cell piece Refl -> unsafeRefl
  , kingExists = case m of
      MoveKing{} -> \sColour' ->
        case sColour %~ sColour' of
          Proved Refl -> SomeKing unsafeRefl sMoveTo
          Disproved _ -> case kingExists bi sColour' of
            SomeKing _ cell -> SomeKing unsafeRefl cell
      -- note: for the last two cases moves allow a king getting
      -- captured, and so king no longer exists for some colour.
      -- when removing unsafeCoerce, we'll need to prove that no
      -- such move can exist, in turn requiring implementing
      -- checkmate on move-level
      CaptureKing{} -> \sColour' ->
        case sColour %~ sColour' of
          Proved Refl -> SomeKing unsafeRefl sMoveTo
          Disproved _ -> case kingExists bi sColour' of
            SomeKing _ cell -> SomeKing unsafeRefl cell
      _ -> \sColour' -> case kingExists bi sColour' of
        SomeKing _ cell -> SomeKing unsafeRefl cell
  }

makeMove :: Move colour moveFrom moveTo facts facts' -> Board facts -> Board facts'
makeMove !_ Board = Board

data SomeKing colour facts where
  SomeKing
    :: (FactHolds (HasKing colour cell) facts :~: 'True)
    -> SCell cell
    -> SomeKing colour facts
